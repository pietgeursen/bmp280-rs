<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Bit-level packing and unpacking for Rust"><meta name="keywords" content="rust, rustlang, rust-lang, packed_struct"><title>packed_struct - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../packed_struct/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><p class="location">Crate packed_struct</p><div class="block version"><p>Version 0.5.0</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all packed_struct's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Definitions</a></li></ul></div><p class="location"></p><div id="sidebar-vars" data-name="packed_struct" data-ty="mod" data-relpath="../"></div></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="">packed_struct</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/packed_struct/lib.rs.html#1-389" title="goto source code">[src]</a></span></h1><div class="docblock"><h1 id="bit-level-packing-and-unpacking-for-rust" class="section-header"><a href="#bit-level-packing-and-unpacking-for-rust">Bit-level packing and unpacking for Rust</a></h1>
<p><a href="https://crates.io/crates/packed_struct"><img src="https://img.shields.io/crates/v/packed_struct.svg" alt="Crates.io" /></a>
<a href="https://docs.rs/packed_struct"><img src="https://docs.rs/packed_struct/badge.svg" alt="Documentation" /></a>
<img src="https://github.com/hashmismatch/packed_struct.rs/workflows/Rust/badge.svg" alt="master" /></p>
<h1 id="introduction" class="section-header"><a href="#introduction">Introduction</a></h1>
<p>Packing and unpacking bit-level structures is usually a programming tasks that needlessly reinvents the wheel. This library provides
a meta-programming approach, using attributes to define fields and how they should be packed. The resulting trait implementations
provide safe packing, unpacking and runtime debugging formatters with per-field documentation generated for each structure.</p>
<h1 id="features" class="section-header"><a href="#features">Features</a></h1>
<ul>
<li>Plain Rust structures, decorated with attributes</li>
<li>MSB or LSB integers of user-defined bit widths</li>
<li>Primitive enum code generation helper</li>
<li>MSB0 or LSB0 bit positioning</li>
<li>Documents the field’s packing table</li>
<li>Runtime packing visualization</li>
<li>Nested packed types</li>
<li>Arrays of packed structures as fields</li>
<li>Reserved fields, their bits are always 0 or 1</li>
</ul>
<h1 id="crate-level-feature-flags" class="section-header"><a href="#crate-level-feature-flags">Crate-level feature flags</a></h1>
<ul>
<li><code>std</code>: use the Rust standard library. Default.</li>
<li><code>alloc</code>: use the <code>alloc</code> crate for <code>no_std</code> + <code>alloc</code> scenarios. Requires nightly Rust.</li>
<li><code>use_serde</code>: add serialization support to the built-in helper types.</li>
<li><code>byte_types_64</code>, <code>byte_types_256</code>: enlarge the size of the generated array, byte and bit width types.</li>
</ul>
<h1 id="sample-usage" class="section-header"><a href="#sample-usage">Sample usage</a></h1><h2 id="cargotoml" class="section-header"><a href="#cargotoml">Cargo.toml</a></h2>
<pre><code class="language-toml">[dependencies]
packed_struct = &quot;0.5&quot;
</code></pre>
<h2 id="importing-the-library-with-the-the-most-common-traits-and-the-derive-macros" class="section-header"><a href="#importing-the-library-with-the-the-most-common-traits-and-the-derive-macros">Importing the library with the the most common traits and the derive macros</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// This is only needed for pre Rust 2018</span>
<span class="attribute">#[<span class="ident">macro_use</span>]</span> <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">packed_struct</span>;
<span class="comment">// Prelude import with the common imports</span>
<span class="kw">use</span> <span class="ident">packed_struct</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;</pre></div>
<h2 id="example-of-a-single-byte-structure-with-a-3-bit-integer-primitive-enum-and-a-bool-field" class="section-header"><a href="#example-of-a-single-byte-structure-with-a-3-bit-integer-primitive-enum-and-a-bool-field">Example of a single-byte structure, with a 3 bit integer, primitive enum and a bool field.</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">packed_struct</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">PackedStruct</span>)]</span>
<span class="attribute">#[<span class="ident">packed_struct</span>(<span class="ident">bit_numbering</span><span class="op">=</span><span class="string">&quot;msb0&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">TestPack</span> {
    <span class="attribute">#[<span class="ident">packed_field</span>(<span class="ident">bits</span><span class="op">=</span><span class="string">&quot;0..=2&quot;</span>)]</span>
    <span class="ident">tiny_int</span>: <span class="ident">Integer</span><span class="op">&lt;</span><span class="ident">u8</span>, <span class="ident">packed_bits</span>::<span class="ident">Bits3</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">packed_field</span>(<span class="ident">bits</span><span class="op">=</span><span class="string">&quot;3..=4&quot;</span>, <span class="ident">ty</span><span class="op">=</span><span class="string">&quot;enum&quot;</span>)]</span>
    <span class="ident">mode</span>: <span class="ident">SelfTestMode</span>,
    <span class="attribute">#[<span class="ident">packed_field</span>(<span class="ident">bits</span><span class="op">=</span><span class="string">&quot;7&quot;</span>)]</span>
    <span class="ident">enabled</span>: <span class="ident">bool</span>
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">PrimitiveEnum_u8</span>, <span class="ident">Clone</span>, <span class="ident">Copy</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">SelfTestMode</span> {
    <span class="ident">NormalMode</span> <span class="op">=</span> <span class="number">0</span>,
    <span class="ident">PositiveSignSelfTest</span> <span class="op">=</span> <span class="number">1</span>,
    <span class="ident">NegativeSignSelfTest</span> <span class="op">=</span> <span class="number">2</span>,
    <span class="ident">DebugMode</span> <span class="op">=</span> <span class="number">3</span>,
}

<span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">PackingError</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">test</span> <span class="op">=</span> <span class="ident">TestPack</span> {
        <span class="ident">tiny_int</span>: <span class="number">5</span>.<span class="ident">into</span>(),
        <span class="ident">mode</span>: <span class="ident">SelfTestMode</span>::<span class="ident">DebugMode</span>,
        <span class="ident">enabled</span>: <span class="bool-val">true</span>
    };

    <span class="comment">// pack into a byte array</span>
    <span class="kw">let</span> <span class="ident">packed</span>: [<span class="ident">u8</span>; <span class="number">1</span>] <span class="op">=</span> <span class="ident">test</span>.<span class="ident">pack</span>()<span class="question-mark">?</span>;
    <span class="macro">assert_eq</span><span class="macro">!</span>([<span class="number">0b10111001</span>], <span class="ident">packed</span>);

    <span class="comment">// unpack from a byte array</span>
    <span class="kw">let</span> <span class="ident">unpacked</span> <span class="op">=</span> <span class="ident">TestPack</span>::<span class="ident">unpack</span>(<span class="kw-2">&amp;</span><span class="ident">packed</span>)<span class="question-mark">?</span>;
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">*</span><span class="ident">unpacked</span>.<span class="ident">tiny_int</span>, <span class="number">5</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">unpacked</span>.<span class="ident">mode</span>, <span class="ident">SelfTestMode</span>::<span class="ident">DebugMode</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">unpacked</span>.<span class="ident">enabled</span>, <span class="bool-val">true</span>);

    <span class="comment">// or unpack from a slice</span>
    <span class="kw">let</span> <span class="ident">unpacked</span> <span class="op">=</span> <span class="ident">TestPack</span>::<span class="ident">unpack_from_slice</span>(<span class="kw-2">&amp;</span><span class="ident">packed</span>[..])<span class="question-mark">?</span>;

    <span class="prelude-val">Ok</span>(())
}</pre></div>
<h1 id="packing-attributes" class="section-header"><a href="#packing-attributes">Packing attributes</a></h1><h2 id="syntax" class="section-header"><a href="#syntax">Syntax</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">packed_struct</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">PackedStruct</span>)]</span>
<span class="attribute">#[<span class="ident">packed_struct</span>(<span class="ident">attr1</span><span class="op">=</span><span class="string">&quot;val&quot;</span>, <span class="ident">attr2</span><span class="op">=</span><span class="string">&quot;val&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Structure</span> {
    <span class="attribute">#[<span class="ident">packed_field</span>(<span class="ident">attr1</span><span class="op">=</span><span class="string">&quot;val&quot;</span>, <span class="ident">attr2</span><span class="op">=</span><span class="string">&quot;val&quot;</span>)]</span>
    <span class="ident">field</span>: <span class="ident">u8</span>
}</pre></div>
<h2 id="per-structure-attributes" class="section-header"><a href="#per-structure-attributes">Per-structure attributes</a></h2><table><thead><tr><th align="left">Attribute</th><th align="left">Values</th><th align="left">Comment</th></tr></thead><tbody>
<tr><td align="left"><code>size_bytes</code></td><td align="left"><code>1</code> … n</td><td align="left">Size of the packed byte stream</td></tr>
<tr><td align="left"><code>bit_numbering</code></td><td align="left"><code>msb0</code> or <code>lsb0</code></td><td align="left">Bit numbering for bit positioning of fields. Required if the bits attribute field is used.</td></tr>
<tr><td align="left"><code>endian</code></td><td align="left"><code>msb</code> or <code>lsb</code></td><td align="left">Default integer endianness</td></tr>
</tbody></table>
<h2 id="per-field-attributes" class="section-header"><a href="#per-field-attributes">Per-field attributes</a></h2><table><thead><tr><th align="left">Attribute</th><th align="left">Values</th><th align="left">Comment</th></tr></thead><tbody>
<tr><td align="left"><code>bits</code></td><td align="left"><code>0</code>, <code>0..1</code>, …</td><td align="left">Position of the field in the packed structure. Three modes are supported: a single bit, the starting bit, or a range of bits. See details below.</td></tr>
<tr><td align="left"><code>bytes</code></td><td align="left"><code>0</code>, <code>0..1</code>, …</td><td align="left">Same as above, multiplied by 8.</td></tr>
<tr><td align="left"><code>size_bits</code></td><td align="left"><code>1</code>, …</td><td align="left">Specifies the size of the packed structure. Mandatory for certain types. Specifying a range of bits like <code>bits=&quot;0..2&quot;</code> can substite the required usage of <code>size_bits</code>.</td></tr>
<tr><td align="left"><code>size_bytes</code></td><td align="left"><code>1</code>, …</td><td align="left">Same as above, multiplied by 8.</td></tr>
<tr><td align="left"><code>element_size_bits</code></td><td align="left"><code>1</code>, …</td><td align="left">For packed arrays, specifies the size of a single element of the array. Explicitly stating the size of the entire array can substite the usage of this attribute.</td></tr>
<tr><td align="left"><code>element_size_bytes</code></td><td align="left"><code>1</code>, …</td><td align="left">Same as above, multiplied by 8.</td></tr>
<tr><td align="left"><code>ty</code></td><td align="left"><code>enum</code></td><td align="left">Packing helper for primitive enums.</td></tr>
<tr><td align="left"><code>endian</code></td><td align="left"><code>msb</code> or <code>lsb</code></td><td align="left">Integer endianness. Applies to u16/i16 and larger types.</td></tr>
</tbody></table>
<h2 id="bit-and-byte-positioning" class="section-header"><a href="#bit-and-byte-positioning">Bit and byte positioning</a></h2>
<p>Used for either <code>bits</code> or <code>bytes</code> on fields. The examples are for MSB0 positioning.</p>
<table><thead><tr><th align="left">Value</th><th align="left">Comment</th></tr></thead><tbody>
<tr><td align="left"><code>0</code></td><td align="left">A single bit or byte</td></tr>
<tr><td align="left"><code>0..</code>, <code>0:</code></td><td align="left">The field starts at bit zero</td></tr>
<tr><td align="left"><code>0..2</code></td><td align="left">Exclusive range, bits zero and one</td></tr>
<tr><td align="left"><code>0:1</code>, <code>0..=1</code></td><td align="left">Inclusive range, bits zero and one</td></tr>
</tbody></table>
<h1 id="more-examples" class="section-header"><a href="#more-examples">More examples</a></h1><h2 id="mixed-endian-integers" class="section-header"><a href="#mixed-endian-integers">Mixed endian integers</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">packed_struct</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">PackedStruct</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">EndianExample</span> {
    <span class="attribute">#[<span class="ident">packed_field</span>(<span class="ident">endian</span><span class="op">=</span><span class="string">&quot;lsb&quot;</span>)]</span>
    <span class="ident">int1</span>: <span class="ident">u16</span>,
    <span class="attribute">#[<span class="ident">packed_field</span>(<span class="ident">endian</span><span class="op">=</span><span class="string">&quot;msb&quot;</span>)]</span>
    <span class="ident">int2</span>: <span class="ident">i32</span>
}

<span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">PackingError</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">example</span> <span class="op">=</span> <span class="ident">EndianExample</span> {
        <span class="ident">int1</span>: <span class="number">0xBBAA</span>,
        <span class="ident">int2</span>: <span class="number">0x11223344</span>
    };

    <span class="kw">let</span> <span class="ident">packed</span> <span class="op">=</span> <span class="ident">example</span>.<span class="ident">pack</span>()<span class="question-mark">?</span>;
    <span class="macro">assert_eq</span><span class="macro">!</span>([<span class="number">0xAA</span>, <span class="number">0xBB</span>, <span class="number">0x11</span>, <span class="number">0x22</span>, <span class="number">0x33</span>, <span class="number">0x44</span>], <span class="ident">packed</span>);
    <span class="prelude-val">Ok</span>(())
}</pre></div>
<h2 id="24-bit-lsb-integers" class="section-header"><a href="#24-bit-lsb-integers">24 bit LSB integers</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">packed_struct</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">PackedStruct</span>)]</span>
<span class="attribute">#[<span class="ident">packed_struct</span>(<span class="ident">endian</span><span class="op">=</span><span class="string">&quot;lsb&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">LsbIntExample</span> {
    <span class="ident">int1</span>: <span class="ident">Integer</span><span class="op">&lt;</span><span class="ident">u32</span>, <span class="ident">packed_bits</span>::<span class="ident">Bits24</span><span class="op">&gt;</span>,
}

<span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">PackingError</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">example</span> <span class="op">=</span> <span class="ident">LsbIntExample</span> {
        <span class="ident">int1</span>: <span class="number">0xCCBBAA</span>.<span class="ident">into</span>()
    };

    <span class="kw">let</span> <span class="ident">packed</span> <span class="op">=</span> <span class="ident">example</span>.<span class="ident">pack</span>()<span class="question-mark">?</span>;
    <span class="macro">assert_eq</span><span class="macro">!</span>([<span class="number">0xAA</span>, <span class="number">0xBB</span>, <span class="number">0xCC</span>], <span class="ident">packed</span>);
    <span class="prelude-val">Ok</span>(())
}</pre></div>
<h2 id="nested-packed-types-within-arrays" class="section-header"><a href="#nested-packed-types-within-arrays">Nested packed types within arrays</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">packed_struct</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">PackedStruct</span>, <span class="ident">Default</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>)]</span>
<span class="attribute">#[<span class="ident">packed_struct</span>(<span class="ident">bit_numbering</span><span class="op">=</span><span class="string">&quot;msb0&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">TinyFlags</span> {
    <span class="ident">_reserved</span>: <span class="ident">ReservedZero</span><span class="op">&lt;</span><span class="ident">packed_bits</span>::<span class="ident">Bits4</span><span class="op">&gt;</span>,
    <span class="ident">flag1</span>: <span class="ident">bool</span>,
    <span class="ident">val1</span>: <span class="ident">Integer</span><span class="op">&lt;</span><span class="ident">u8</span>, <span class="ident">packed_bits</span>::<span class="ident">Bits2</span><span class="op">&gt;</span>,
    <span class="ident">flag2</span>: <span class="ident">bool</span>
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">PackedStruct</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Settings</span> {
    <span class="attribute">#[<span class="ident">packed_field</span>(<span class="ident">element_size_bits</span><span class="op">=</span><span class="string">&quot;4&quot;</span>)]</span>
    <span class="ident">values</span>: [<span class="ident">TinyFlags</span>; <span class="number">4</span>]
}

<span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">PackingError</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">example</span> <span class="op">=</span> <span class="ident">Settings</span> {
        <span class="ident">values</span>: [
            <span class="ident">TinyFlags</span> { <span class="ident">flag1</span>: <span class="bool-val">true</span>,  <span class="ident">val1</span>: <span class="number">1</span>.<span class="ident">into</span>(), <span class="ident">flag2</span>: <span class="bool-val">false</span>, .. <span class="ident">TinyFlags</span>::<span class="ident">default</span>() },
            <span class="ident">TinyFlags</span> { <span class="ident">flag1</span>: <span class="bool-val">true</span>,  <span class="ident">val1</span>: <span class="number">2</span>.<span class="ident">into</span>(), <span class="ident">flag2</span>: <span class="bool-val">true</span>,  .. <span class="ident">TinyFlags</span>::<span class="ident">default</span>() },
            <span class="ident">TinyFlags</span> { <span class="ident">flag1</span>: <span class="bool-val">false</span>, <span class="ident">val1</span>: <span class="number">3</span>.<span class="ident">into</span>(), <span class="ident">flag2</span>: <span class="bool-val">false</span>, .. <span class="ident">TinyFlags</span>::<span class="ident">default</span>() },
            <span class="ident">TinyFlags</span> { <span class="ident">flag1</span>: <span class="bool-val">true</span>,  <span class="ident">val1</span>: <span class="number">0</span>.<span class="ident">into</span>(), <span class="ident">flag2</span>: <span class="bool-val">false</span>, .. <span class="ident">TinyFlags</span>::<span class="ident">default</span>() },
        ]
    };

    <span class="kw">let</span> <span class="ident">packed</span> <span class="op">=</span> <span class="ident">example</span>.<span class="ident">pack</span>()<span class="question-mark">?</span>;
    <span class="kw">let</span> <span class="ident">unpacked</span> <span class="op">=</span> <span class="ident">Settings</span>::<span class="ident">unpack</span>(<span class="kw-2">&amp;</span><span class="ident">packed</span>)<span class="question-mark">?</span>;

    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">example</span>, <span class="ident">unpacked</span>);
    <span class="prelude-val">Ok</span>(())
}</pre></div>
<h1 id="primitive-enums-with-simple-discriminants" class="section-header"><a href="#primitive-enums-with-simple-discriminants">Primitive enums with simple discriminants</a></h1>
<p>Supported backing integer types: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>.</p>
<p>Explicit or implicit backing type:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">packed_struct</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">PrimitiveEnum</span>, <span class="ident">Clone</span>, <span class="ident">Copy</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">ImplicitType</span> {
    <span class="ident">VariantMin</span> <span class="op">=</span> <span class="number">0</span>,
    <span class="ident">VariantMax</span> <span class="op">=</span> <span class="number">255</span>
}
 
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">PrimitiveEnum_i16</span>, <span class="ident">Clone</span>, <span class="ident">Copy</span>)]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">ExplicitType</span> {
    <span class="ident">VariantMin</span> <span class="op">=</span> <span class="op">-</span><span class="number">32768</span>,
    <span class="ident">VariantMax</span> <span class="op">=</span> <span class="number">32767</span>
}
 
<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">use</span> <span class="ident">packed_struct</span>::<span class="ident">PrimitiveEnum</span>;
     
    <span class="kw">let</span> <span class="ident">t</span> <span class="op">=</span> <span class="ident">ImplicitType</span>::<span class="ident">VariantMin</span>;
    <span class="kw">let</span> <span class="ident">tn</span>: <span class="ident">u8</span> <span class="op">=</span> <span class="ident">t</span>.<span class="ident">to_primitive</span>();
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">0</span>, <span class="ident">tn</span>);

    <span class="kw">let</span> <span class="ident">t</span> <span class="op">=</span> <span class="ident">ImplicitType</span>::<span class="ident">from_primitive</span>(<span class="number">255</span>).<span class="ident">unwrap</span>();
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">ImplicitType</span>::<span class="ident">VariantMax</span>, <span class="ident">t</span>);
}</pre></div>
<h1 id="primitive-enum-packing-with-support-for-catch-all-unknown-values" class="section-header"><a href="#primitive-enum-packing-with-support-for-catch-all-unknown-values">Primitive enum packing with support for catch-all unknown values</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">packed_struct</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
 
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">PrimitiveEnum_u8</span>, <span class="ident">Debug</span>, <span class="ident">Clone</span>, <span class="ident">Copy</span>)]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">Field</span> {
    <span class="ident">A</span> <span class="op">=</span> <span class="number">1</span>,
    <span class="ident">B</span> <span class="op">=</span> <span class="number">2</span>,
    <span class="ident">C</span> <span class="op">=</span> <span class="number">3</span>
}
 
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">PackedStruct</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>)]</span>
<span class="attribute">#[<span class="ident">packed_struct</span>(<span class="ident">bit_numbering</span><span class="op">=</span><span class="string">&quot;msb0&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Register</span> {
    <span class="attribute">#[<span class="ident">packed_field</span>(<span class="ident">bits</span><span class="op">=</span><span class="string">&quot;0..4&quot;</span>, <span class="ident">ty</span><span class="op">=</span><span class="string">&quot;enum&quot;</span>)]</span>
    <span class="ident">field</span>: <span class="ident">EnumCatchAll</span><span class="op">&lt;</span><span class="ident">Field</span><span class="op">&gt;</span>
}
 </pre></div>
</div><h2 id="modules" class="section-header"><a href="#modules">Modules</a></h2>
<table><tr class="module-item"><td><a class="mod" href="derive/index.html" title="packed_struct::derive mod">derive</a></td><td class="docblock-short"><p>The derivation macros for packing and enums.</p>
</td></tr><tr class="module-item"><td><a class="mod" href="prelude/index.html" title="packed_struct::prelude mod">prelude</a></td><td class="docblock-short"><p>Re-exports the most useful traits and types. Meant to be glob imported.</p>
</td></tr><tr class="module-item"><td><a class="mod" href="types/index.html" title="packed_struct::types mod">types</a></td><td class="docblock-short"><p>Implementations and wrappers for various packing types.</p>
</td></tr><tr class="module-item"><td><a class="mod" href="types_tuples/index.html" title="packed_struct::types_tuples mod">types_tuples</a></td><td class="docblock-short"><p>Tuples of types that can be packed together. Only byte-sized structures can be chained together.</p>
</td></tr></table><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2>
<table><tr class="module-item"><td><a class="enum" href="enum.EnumCatchAll.html" title="packed_struct::EnumCatchAll enum">EnumCatchAll</a></td><td class="docblock-short"><p>A wrapper for primitive enums that supports catching and retaining any values
that don’t have defined discriminants.</p>
</td></tr><tr class="module-item"><td><a class="enum" href="enum.PackingError.html" title="packed_struct::PackingError enum">PackingError</a></td><td class="docblock-short"><p>Packing errors that might occur during packing or unpacking</p>
</td></tr></table><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2>
<table><tr class="module-item"><td><a class="trait" href="trait.PackedStruct.html" title="packed_struct::PackedStruct trait">PackedStruct</a></td><td class="docblock-short"><p>A structure that can be packed and unpacked from a byte array.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.PackedStructInfo.html" title="packed_struct::PackedStructInfo trait">PackedStructInfo</a></td><td class="docblock-short"><p>Infos about a particular type that can be packaged.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.PackedStructSlice.html" title="packed_struct::PackedStructSlice trait">PackedStructSlice</a></td><td class="docblock-short"><p>A structure that can be packed and unpacked from a slice of bytes.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.PrimitiveEnum.html" title="packed_struct::PrimitiveEnum trait">PrimitiveEnum</a></td><td class="docblock-short"><p>An enum type that can be packed or unpacked from a simple primitive integer.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.PrimitiveEnumStaticStr.html" title="packed_struct::PrimitiveEnumStaticStr trait">PrimitiveEnumStaticStr</a></td><td class="docblock-short"><p>Static display formatters.</p>
</td></tr></table><h2 id="types" class="section-header"><a href="#types">Type Definitions</a></h2>
<table><tr class="module-item"><td><a class="type" href="type.PackingResult.html" title="packed_struct::PackingResult type">PackingResult</a></td><td class="docblock-short"></td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="packed_struct" data-search-js="../search-index.js"></div>
    <script src="../main.js"></script></body></html>